/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: unknown
 * Options:   --no-arrays --no-structs --no-unions --no-safe-math --no-pointers --no-longlong --max-funcs 1 --max-expr-complexity 5 --output ./tmp/src_code/csmith_test_1382.c
 * Seed:      1193340821
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */
static int16_t g_4 = 0x532B;
static int32_t g_12 = 0xC4475EE4;
static uint8_t g_15 = 2U;
static uint8_t g_35 = 0xDA;
static int8_t g_38 = (-1);
static int32_t g_59 = 7;
static int32_t g_64 = 0xA587DEF5;
static int32_t g_129 = 0x51B32B03;
static int32_t g_137 = 0x6E95F59A;
static uint32_t g_138 = 0x5BB39443;
static uint8_t g_200 = 0x80;
static volatile int32_t g_203 = 0x2908FF2C;/* VOLATILE GLOBAL g_203 */
static uint8_t g_204 = 0xE1;
static int8_t g_215 = (-10);
static volatile int8_t g_241 = 1;/* VOLATILE GLOBAL g_241 */
static volatile uint32_t g_245 = 0xB431681A;/* VOLATILE GLOBAL g_245 */
static int32_t g_267 = (-1);
static volatile uint8_t g_268 = 255U;/* VOLATILE GLOBAL g_268 */
static volatile uint16_t g_312 = 0x4CFA;/* VOLATILE GLOBAL g_312 */
static int16_t g_372 = 0;
static uint16_t g_379 = 0x2D69;
static volatile int32_t g_409 = 0xE238FD6C;/* VOLATILE GLOBAL g_409 */
static volatile int16_t g_411 = 1;/* VOLATILE GLOBAL g_411 */
static uint16_t g_413 = 0x101B;
static const volatile uint32_t g_587 = 1U;/* VOLATILE GLOBAL g_587 */


/* --- FORWARD DECLARATIONS --- */
static int16_t  func_1(void);



static int set_var(int16_t g_4_l, int32_t g_12_l, uint8_t g_15_l, uint8_t g_35_l, int8_t g_38_l, int32_t g_59_l, int32_t g_64_l, int32_t g_129_l, int32_t g_137_l, uint32_t g_138_l, uint8_t g_200_l, int32_t g_203_l, uint8_t g_204_l, int8_t g_215_l, int8_t g_241_l, uint32_t g_245_l, int32_t g_267_l, uint8_t g_268_l, uint16_t g_312_l, int16_t g_372_l, uint16_t g_379_l, int32_t g_409_l, int16_t g_411_l, uint16_t g_413_l){
    g_4 = g_4_l;g_12 = g_12_l;g_15 = g_15_l;g_35 = g_35_l;g_38 = g_38_l;g_59 = g_59_l;g_64 = g_64_l;g_129 = g_129_l;g_137 = g_137_l;g_138 = g_138_l;g_200 = g_200_l;g_203 = g_203_l;g_204 = g_204_l;g_215 = g_215_l;g_241 = g_241_l;g_245 = g_245_l;g_267 = g_267_l;g_268 = g_268_l;g_312 = g_312_l;g_372 = g_372_l;g_379 = g_379_l;g_409 = g_409_l;g_411 = g_411_l;g_413 = g_413_l;
    return 0;
}
/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_4 g_15 g_12 g_35 g_38 g_59 g_64 g_129 g_138 g_137 g_200 g_204 g_215 g_245 g_241 g_268 g_267 g_312 g_203 g_379 g_372 g_413 g_409 g_411 g_587
 * writes: g_4 g_15 g_12 g_35 g_38 g_59 g_64 g_129 g_138 g_200 g_204 g_215 g_245 g_268 g_267 g_312 g_372 g_379 g_413 g_409
 */
static int16_t  func_1(void)
{    unsigned int stack0xffffffe8, unique0x10000970, unique0x00000f40, unique0x1000091b;

    uint8_t uVar1;
    char cVar2;
    uint8_t uVar3;
    int16_t iVar4;
    uint32_t uVar5;
    uint32_t var_1bch;
    int var_1b8h;
    uint32_t var_1b4h;
    int32_t var_1b0h;
    uint32_t var_1ach;
    uint32_t var_1a8h;
    uint32_t var_1a4h;
    uint32_t var_1a0h;
    uint32_t var_194h;
    int32_t var_190h;
    int32_t var_18ch;
    int32_t var_184h;
    int32_t var_180h;
    int32_t var_178h;
    int32_t var_174h;
    uint32_t var_170h;
    int32_t var_16ch;
    int32_t var_168h;
    uint32_t var_164h;
    int32_t var_160h;
    int32_t var_15ch;
    int32_t var_158h;
    int32_t var_150h;
    int32_t var_14ch;
    uint32_t var_148h;
    int32_t var_144h;
    uint32_t var_13ch;
    uint32_t var_138h;
    uint32_t var_134h;
    uint32_t var_12ch;
    uint32_t var_128h;
    uint32_t var_124h;
    int32_t var_120h;
    uint32_t var_11ch;
    uint32_t var_118h;
    int32_t var_110h;
    int32_t var_10ch;
    int32_t var_104h;
    int32_t var_100h;
    uint32_t var_f8h;
    int32_t var_ech;
    uint32_t var_e4h;
    int32_t var_e0h;
    int32_t var_d8h;
    uint32_t var_d4h;
    int32_t var_cch;
    uint32_t var_c0h;
    int32_t var_b8h;
    uint32_t var_b4h;
    int32_t var_b0h;
    int32_t var_a8h;
    uint32_t var_a4h;
    uint32_t var_a0h;
    uint32_t var_9ch;
    uint32_t var_94h;
    uint32_t var_90h;
    int32_t var_8ch;
    uint32_t var_88h;
    int32_t var_84h;
    uint32_t var_80h;
    uint32_t var_7ch;
    uint32_t var_78h;
    int32_t var_74h;
    uint32_t var_70h;
    uint32_t var_6ch;
    uint32_t var_68h;
    uint32_t var_64h;
    uint32_t var_5ch;
    uint32_t var_54h;
    uint32_t var_50h;
    uint32_t var_4ch;
    uint16_t var_46h;
    uint32_t var_44h;
    uint16_t var_40h;
    uint16_t var_3eh;
    uint16_t var_3ch;
    uint8_t var_39h;
    int32_t var_38h;
    uint32_t var_34h;
    uint8_t var_2fh;
    uint8_t var_2dh;
    uint32_t var_2ch;
    uint32_t var_28h;
    uint32_t var_24h;
    uint8_t var_1dh;
    uint32_t var_1ch;
    uint32_t var_16h;
    char var_eh;
    uint32_t var_dh;
    
    var_1ch = 0xc4475ee4;
    var_1dh = 2;
    var_eh = -1;
    stack0xffffffe8 = 7;
    var_24h = 0xa587def5;
    var_28h = 0x51b32b03;
    var_2ch = 0x5bb39443;
    var_2dh = 0x80;
    var_2fh = 0xf6;
    var_38h = -1;
    var_39h = 0xff;
    var_3ch = 0x4cfa;
    var_3eh = 0;
    var_40h = 0x2d69;
    var_44h = 0xe238fd6c;
    var_46h = 0x101b;
    var_4ch = 0x6e33a79c;
    var_54h = 0xe653d3a1;
    var_5ch = 0xf7add78b;
    var_64h = 0x22a1230c;
    var_16h = 0x94f3;
    var_68h = 0xffffffff;
    var_6ch = 0x65f9e929;
    var_74h = 0;
code_r0x0804997c:
    uVar3 = var_1dh + 1;
    cVar2 = (char)(uint16_t)var_16h;
    var_1ch = (int32_t)(char)((var_68h != (int32_t)(int16_t)(uint16_t)var_16h) *
                             ((int32_t)var_68h <=
                             (int32_t)((uint32_t)(uint16_t)((int16_t)(char)var_1ch + 1) % (var_1ch & 0xffff))) * cVar2)
              - (int32_t)(char)var_4ch;
    var_dh = 1;
    if (var_1ch == 0x94f3) {
        var_68h = 0x44;
    } else {
        var_68h = 0x45;
    }
    if (var_68h == (int32_t)(int16_t)(uint16_t)var_16h) {
        set_var((int32_t)(int16_t)(uint16_t)var_16h, var_1ch, (uint32_t)uVar3, 1, (int32_t)var_eh, stack0xffffffe8, 
                    var_24h, var_28h, 0x6e95f59a, var_2ch, (uint32_t)var_2dh, 0x2908ff2c, 0xe1, (int32_t)(char)var_2fh, 
                    1, -0x4bce97e6, var_38h, (uint32_t)var_39h, (uint32_t)var_3ch, (int32_t)(int16_t)var_3eh, 
                    (uint32_t)var_40h, var_44h, 1, (uint32_t)var_46h);
        return 1;
    }
    var_78h = 0xa3fdcb73;
    var_80h = 0xe2be1d8a;
    var_eh = '\x01';
    var_4ch = var_4ch & 5;
    if (var_1ch == 0) {
        for (var_24h = 0xd; var_24h != 0xffffffe7; var_24h = var_24h - 1) {
            var_78h = 0x4d;
            uVar1 = (uint8_t)var_dh - 1;
            if ((uVar1 == 9) || (uVar1 == 0x1fc70460)) {
                uVar5 = 0;
            } else {
                uVar5 = 1;
            }
            if (uVar5 != var_24h) {
                set_var((int32_t)(int16_t)(uint16_t)var_16h, 0, (uint32_t)uVar3, (uint32_t)uVar1, (int32_t)var_eh, 
                            stack0xffffffe8, var_24h, var_28h, 0x6e95f59a, var_2ch, (uint32_t)var_2dh, 0x2908ff2c, 0xe1
                            , (int32_t)(char)var_2fh, 1, -0x4bce97e6, var_38h, (uint32_t)var_39h, (uint32_t)var_3ch, 
                            (int32_t)(int16_t)var_3eh, (uint32_t)var_40h, var_44h, 1, (uint32_t)var_46h);
                return (uint16_t)var_16h;
            }
            var_2ch = var_2ch + 1;
            var_dh = (uint8_t)var_dh - 2;
            var_eh = -9;
            var_28h = (uint32_t)(uVar1 != 0xfffffff7);
            unique0x10000970 = var_28h;
            if (var_28h == 0) {
                if (var_2ch != 0) goto code_r0x0804a10d;
                var_2ch = 0xfffffffc;
                *(uint32_t *)0x8 = (int32_t)cVar2 * (int32_t)((uint8_t)var_dh != 0) & 0xe038fb9f;
                var_4ch = 0;
            }
        }
        var_54h = 0xf6addb09;
        var_78h = 0;
        var_28h = var_28h & ((int32_t)(char)((char)(0xf3 >> (((uint8_t)var_2ch & (uint8_t)var_6ch ^ 0x8c) & 0x1f)) >> 6)
                            | stack0xffffffe8);
        *(uint32_t *)0x0 =
             var_2ch - (uint8_t)((uint8_t)(cVar2 + 0x82U) >> 5 ^ 5) & (int32_t)(int16_t)(uint16_t)var_16h ^ 0xf6addb09;
code_r0x0804a10d:
        var_5ch = var_5ch + 1;
        var_2fh = var_2fh | 0x84;
        if ((var_54h == 0) || ((int16_t)(uint16_t)var_16h < (int16_t)(uint16_t)(var_78h == 0))) {
            iVar4 = 0;
        } else {
            iVar4 = 1;
        }
        var_1ch = (int32_t)(int16_t)(iVar4 - (int16_t)var_54h) % -0x6b0d;
        var_1dh = uVar3;
    } else {
        var_eh = var_54h == 0;
        if ((int32_t)var_eh == 0) {
            var_1dh = var_1dh + 2;
            var_78h = 0xfffffff6;
            var_1ch = var_eh * -10;
            var_eh = var_1ch == var_4ch;
        } else {
            var_24h = var_24h | (int32_t)var_eh ^ 1U;
            var_68h = var_68h ^ var_54h;
            var_1dh = 0;
        }
        var_1ch = var_1ch ^ 0x7d;
        for (stack0xffffffe8 = 0; stack0xffffffe8 != 0x1c; unique0x00000f40 = stack0xffffffe8 + 2) {
            var_28h = 0x7769a133;
        }
    }
    var_2ch = 0;
    for (var_2dh = 0; var_2dh != 0x23; var_2dh = var_2dh + 7) {
        var_39h = var_39h + 1;
    }
    for (var_38h = 0; var_38h < 0x1e; var_38h = var_38h + 1) {
        var_28h = 0;
        var_16h = 0;
        var_1ch = var_1ch | 1;
        if (var_1ch == 0) {
            var_78h = 0;
            if ((var_2fh != 0) < 0xe999) {
                var_eh = '\b';
            } else {
                var_eh = '\t';
            }
            unique0x1000091b = var_eh * 5;
            var_28h = 0xffffffff;
            var_54h = (uint32_t)var_39h;
            var_3ch = var_3ch - 1;
        } else {
            var_eh = -1;
            var_2fh = 1;
            *(uint32_t *)0x8 = 0xffffe28c;
        }
    }
    var_84h = 0;
    do {
        if (var_84h < 0xe) {
            set_var((int32_t)(int16_t)(uint16_t)var_16h, var_1ch, (uint32_t)var_1dh, (uint32_t)(uint8_t)var_dh, 
                        (int32_t)var_eh, stack0xffffffe8, var_24h, var_28h, 0x6e95f59a, 0, (uint32_t)var_2dh, 0x2908ff2c
                        , 0xe1, (int32_t)(char)var_2fh, 1, -0x4bce97e6, var_64h + var_2dh, (uint32_t)var_39h, 
                        (uint32_t)var_3ch, (int32_t)(int16_t)var_3eh, (uint32_t)var_40h, var_44h, 1, (uint32_t)var_46h);
            return var_3ch;
        }
        var_88h = 1;
        if (var_2dh == 0) {
            var_80h = 0xbb;
            var_74h = -0x539b3eae;
            if (var_5ch != 0) goto code_r0x0804997c;
            var_88h = (uint16_t)var_16h != 0 ^ var_1ch;
        } else {
            if (((int32_t)(char)var_2fh < (int32_t)(uint32_t)(-0x1d96e9e6 < (int32_t)(uint32_t)var_2dh)) ||
               (var_3ch != 0)) {
                var_38h = 1;
            } else {
                var_38h = 0;
            }
            var_38h = var_38h >> (var_2fh & 0x1f);
        }
        var_50h = 0xfffffff2;
        while (var_50h == 0x13) {
            var_88h = var_88h ^ 0xfffffffa;
            var_3eh = (uint16_t)var_88h;
            var_38h = 1;
            var_50h = 0x14;
        }
        var_40h = 1;
        var_eh = (char)(1 % ((int32_t)(char)var_1dh % 1 & 0xffffU));
        var_64h = (uint32_t)((var_78h & 0xff) + 1 < 0xffff);
        var_dh = (uint8_t)var_dh | var_64h != 0x68;
        if (((uint32_t)(uint8_t)var_dh * 0x2e < 0xefb7) < var_39h) {
            var_2dh = 0x33;
        } else {
            var_2dh = 0x32;
        }
        *(uint32_t *)0x0 = (uint32_t)(var_3eh != 0);
        var_46h = var_46h - 1;
        var_3eh = (uint16_t)
                  (((uint32_t)((uint16_t)(0xd01 % (uint32_t)(uint16_t)(var_2dh | 0x5396)) <= (uint16_t)var_2dh) |
                   var_74h) == 0x694322c4);
        var_54h = ((int16_t)var_3eh);
        var_6ch = 0;
        var_44h = var_80h & var_44h;
        var_84h = var_84h + 1;
        var_80h = var_80h | var_46h != 0x6b0c;
        var_1dh = var_2dh;
    } while( 1 );
}





/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_4, "g_4", print_hash_value);
    transparent_crc(g_12, "g_12", print_hash_value);
    transparent_crc(g_15, "g_15", print_hash_value);
    transparent_crc(g_35, "g_35", print_hash_value);
    transparent_crc(g_38, "g_38", print_hash_value);
    transparent_crc(g_59, "g_59", print_hash_value);
    transparent_crc(g_64, "g_64", print_hash_value);
    transparent_crc(g_129, "g_129", print_hash_value);
    transparent_crc(g_137, "g_137", print_hash_value);
    transparent_crc(g_138, "g_138", print_hash_value);
    transparent_crc(g_200, "g_200", print_hash_value);
    transparent_crc(g_203, "g_203", print_hash_value);
    transparent_crc(g_204, "g_204", print_hash_value);
    transparent_crc(g_215, "g_215", print_hash_value);
    transparent_crc(g_241, "g_241", print_hash_value);
    transparent_crc(g_245, "g_245", print_hash_value);
    transparent_crc(g_267, "g_267", print_hash_value);
    transparent_crc(g_268, "g_268", print_hash_value);
    transparent_crc(g_312, "g_312", print_hash_value);
    transparent_crc(g_372, "g_372", print_hash_value);
    transparent_crc(g_379, "g_379", print_hash_value);
    transparent_crc(g_409, "g_409", print_hash_value);
    transparent_crc(g_411, "g_411", print_hash_value);
    transparent_crc(g_413, "g_413", print_hash_value);
    transparent_crc(g_587, "g_587", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 112
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 31
breakdown:
   depth: 1, occurrence: 107
   depth: 2, occurrence: 12
   depth: 3, occurrence: 1
   depth: 5, occurrence: 1
   depth: 7, occurrence: 1
   depth: 8, occurrence: 3
   depth: 9, occurrence: 3
   depth: 10, occurrence: 8
   depth: 11, occurrence: 3
   depth: 12, occurrence: 3
   depth: 13, occurrence: 3
   depth: 14, occurrence: 5
   depth: 15, occurrence: 4
   depth: 16, occurrence: 7
   depth: 17, occurrence: 2
   depth: 18, occurrence: 1
   depth: 20, occurrence: 1
   depth: 23, occurrence: 1
   depth: 24, occurrence: 2
   depth: 25, occurrence: 3
   depth: 31, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 449
XXX times a non-volatile is write: 147
XXX times a volatile is read: 24
XXX    times read thru a pointer: 0
XXX times a volatile is write: 5
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 168
XXX percentage of non-volatile access: 95.4

XXX forward jumps: 2
XXX backward jumps: 1

XXX stmts: 104
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 5
   depth: 1, occurrence: 9
   depth: 2, occurrence: 9
   depth: 3, occurrence: 16
   depth: 4, occurrence: 25
   depth: 5, occurrence: 40

XXX percentage a fresh-made variable is used: 16.5
XXX percentage an existing variable is used: 83.5
********************* end of statistics **********************/

